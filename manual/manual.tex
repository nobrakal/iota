\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{hyperref}

\usepackage{minted}
\newcommand{\ocaml}{\mintinline{ocaml}}

\usepackage{syntax}

\setcounter{tocdepth}{2}

\author{Alexandre Moine}
\title{Iota - Manual}

\begin{document}

\maketitle
\tableofcontents

\section{Introduction}
Iota is a programming language.

\section{Syntax of the language}
Nota Bene:
\begin{itemize}
\item \verb|[<rule>]| symbolise a list of \verb|<rule>|.
\item \verb|[<rule> // <sep>]| symbolise a list of \verb|<rule>| separated by \verb|<sep>|.
\end{itemize}

Comments Ã -la-OCaml can be used everywhere.

\subsection{Syntax of programs}

\begin{grammar}
  <lident> ::= [a-z][a-zA-Z0-9]*

  <hident> ::= [A-Z][a-zA-Z0-9]*

  <type> ::= <lident>

  <term> ::= <lident>
  \alt `parent<' <type> `,' <type> `>(' <term> `)'
  \alt <term> `.' <lident>

  <guard> ::= `Eq(' <term> `,' <term> `)'
  \alt `Link(' <term> `,' <term> `)'
  \alt `TLink<' <type> `,' <type> `>(' <term> `,' <term> `)'

  <predicate> ::= <guard>
  \alt `Has(' <term> `)'
  \alt <hident> `(' <term> `)'

  <formula> ::= <predicate>
  \alt `+'<predicate>
  \alt `not' <formula>
  \alt <formula> `&&' <formula>
  \alt <formula> `||' <formula>
  \alt `(' <formula> `)'

  <safe> ::= <formula>
  \alt <lident>
  \alt <safe> `&&' <safe>
  \alt <safe> `||' <safe>
  \alt `forall' <lident> <guard> `->' <safe>
  \alt `exists' <lident> <guard> `&&' <safe>
  \alt <safe> <safe>
  \alt `(' <safe> `)'

  <letdef> ::= \lit{let} <lident> [<lident>] \lit{=} <safe>

  <general> ::=
  <guard> \lit{->} <general>
  \alt \lit{=>} <formula>

  <program> ::=
  [<letdef>] \lit{in} [<safe> // \lit{;}] \lit{ensure} [<general> // \lit{;}] \lit{maintain} [<general> // \lit{;}]

\end{grammar}

\subsection{Syntax of configuration file}
\begin{grammar}
  <constants> ::=
  \lit{let} \lit{maxprof} \lit{=} <int>

  <typedef> ::=
  \lit{type} <lident>
  \alt \lit{type} <lident> \lit{=} [<lident> \lit{to} <type> // \lit{|} ]

  <preddef> ::=
  \lit{static} <hident> \lit{about} <lident>
  \alt \lit{dynamic} <hident> \lit{about} <lident>

  <config> ::=
  <constants> [<typedef>] [<preddef>]
\end{grammar}

\subsection{Semantics of the configuration file}
\subsection{The maxporf parameter}
All trees have \emph{bound} size, thus one must specify the maximum size of a tree.

\subsection{Types}
Nodes, leaves and some operations on trees are \emph{typed}.
\begin{itemize}
\item Types without accessors. They will represent leaves.
\item Types with accesors. They will represent nodes. Each accessor is composed by a name and a type.
  This indicates the type of the child and how to access it.
\end{itemize}

\subsection{Predicates}
Finally, one have to define predicates. A predicate gives information about a node of some type.

\subsection{Example}
Here is a valid configuration file:
\begin{minted}[frame=lines]{ocaml}
let maxprof = 10

type site
type mol = m to mol | f to site | g to site

static E about mol
dynamic Active about mol
dynamic Open about site
\end{minted}

This file declares two types:

\begin{itemize}
\item A leaf \ocaml{site}.
\item A node \ocaml{mol} with three possible children:
  \begin{itemize}
  \item An other node \ocaml{mol}.
  \item Two sites \ocaml{f} and \ocaml{g}.
  \end{itemize}
\end{itemize}

\section{Semantics of a iota file}

\subsection{Propositional formulas}
All iota files are \emph{in fine} a list of simple formulas.

\paragraph{Literals}
Formulas are about literals. A iota literal is either:
\begin{itemize}
\item A name.
\item A child of a literal.
\item The parent of a literal.
\end{itemize}

\paragraph{Predicates}
Predicates can be used to extract information about literals. Some predicates are bundled into the iota syntax itself:
\begin{itemize}
\item \ocaml{Eq} is a binary predicate expressing the fact that two literals are equals. It can be applied to literals of any types.
\item \ocaml{Link} is a binary predicate expressing the fact that two literals are linked. It can be applied to literals of any types.
\item \ocaml{TLink<t1,t2>} is a binary predicate expressing the fact that the two trees from the literals are linked. Its arguments must be of type \ocaml{t1} and \ocaml{t2}.
\item \ocaml{Has} is a unary predicate expressing the \emph{presence} of a literal. It can be applied to literal of any types.
\end{itemize}

The user can specify other predicates using the configuration file. Note that user-defined predicates are \emph{typed}, meaning that, once defined, they can be applied only to one type of literal.

\paragraph{Static vs Dynamic}
Predicates are separated into two categories: static and dynamic. Dynamic predicates can be prepended with the symbol \ocaml{+}. \ocaml{Eq}, \ocaml{Link} and \ocaml{Has} are dynamic.

\paragraph{Formulas}
Then you can build propositional formulas over these (fully applied) predicates using usual combinators \ocaml{not}, \ocaml{&&} and \ocaml{||}.

\paragraph{Examples}
Here is some examples using the previous configuration:
\begin{minted}[frame=lines]{ocaml}
Active(x);
Active(x) && not (Active (x.m));
Has(x) && (not (Open(x.t)) || +Link(x.t,y.g))
\end{minted}

\subsection{Toward first-order}
Then, one can construct first-order formulas using the two following structures:
\begin{itemize}
\item \ocaml{forall x, guard(x,y) -> formula(x)}
\item \ocaml{exists x, guard(x,y) && formula(x)}
\end{itemize}
Notice that each quantifies variable is \emph{guarded}.

\subsection{Writing programs}
Now, we can wire up all these definitions using a standard let-syntax.

\section{The compilation back-end}
The compilation is divided into 4 steps:
\begin{enumerate}
\item Parsing.
\item Typechecking.
\item Compilation itself.
\item Verification of the resulting structure.
\end{enumerate}

\subsection{Parsing}
The described syntax is parsed using the great Menhir: \url{http://gallium.inria.fr/~fpottier/menhir/}.

\subsection{Typechecking}
Programs are typechecked (using algorithm W) to ensure the validity of the file. Most of the inference is trivial. There is a challenge to infer the type of an expression using \ocaml{parent} since its usage introduce requirements about its argument (in the expression \ocaml{parent(x)}, \ocaml{x} must not be a root). This is bypassed using explicit typing of this operator.

\subsubsection{Guard inference}

\subsection{Compilation}
The compilation itself is divided into sub-steps.

\paragraph{Inlining}
All the definitions of \verb|Iota| are \emph{pure}, ie. without any effects, so one can always replace a call to a function by its body with proper substitution. This is the first thing the compiler do, since it allows to totally remove let-definitions. There is two sides effects:

\begin{itemize}
\item Unused definitions are not included in the result of the compilation. They still need to typecheck.
\item The size of the produced formula can be large since many things will be duplicated.
\end{itemize}

\paragraph{Compilation of TLink}
The \ocaml{Tlink} predicate is not included in the target language, so we need to compile it.

\paragraph{Normal form of formulas}
Any formula can be put in \emph{normal form}, where negation is only present on leaves. This is done.

\paragraph{Optimization}
The compiler can now do some optimization. It actually does only one, by replacing expressions of the form:
\begin{minted}{ocaml}
parent<t1,t2>(x.f)
\end{minted}
by
\begin{minted}{ocaml}
x
\end{minted}
Note that this optimization is legal in the sense that, since the program typecheck, we know that \ocaml{x.f} is a valid object.

\subsection{Verification}
The resulting structure must satisfies some properties.

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
