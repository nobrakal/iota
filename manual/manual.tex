\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{hyperref}
\usepackage{subfig}
\usepackage{multicol}

\newcommand\Iota{\textsc{Iota}}
\newcommand\Menhir{\textsc{Menhir}}
\newcommand\Odoc{\textsc{Odoc}}
\newcommand\Ocaml{\textsc{OCaml}}
\newcommand\Dune{\textsc{Dune}}
\newcommand\Kappa{\textsc{Kappa}}

\usepackage{minted}
\newcommand{\ocaml}{\mintinline{ocaml}}

\usepackage{syntax}

\setcounter{tocdepth}{1}

\author{Alexandre Moine}
\title{Iota - Manual}

\begin{document}

\maketitle
\tableofcontents

\section{Introduction}
\Iota{} is a programming language targeting the logic developed in Husson's thesis \cite{husson}. More specifically, it targets a ``safe'' subset of Husson's logic (section 5), for which we know an algorithm able to synthesize equivalent \Kappa{} rules.

Sadly, it is tedious to write directly formulas in this logic, and criterion of correction need to be carefully hand-checked. Moreover, since the previously mentioned algorithm to synthesize \Kappa{} rules is doubly exponential, hand-written formulas can lead to an enormous number of rules, frequently equivalent to a much smaller set.

Hence, there was a need for an intermediate language that is still made for experts but allowing the programmer to focus on describing its system rather than dealing with the formalism of the logic.

\Iota{} is an experiment trying to address these difficulties: the compiler comes with a powerful type system, several static analysis and optimizations. The language also provides programming facilities through a powerful inference, and the possibility to extend and constrain the type system.

\section{Semantics of the configuration file}
A \Iota{} program needs to be configured. For this purpose, the user needs to provide a configuration file separated in three parts:
\begin{enumerate}
\item The definition of constants.
\item The definition of types of objects.
\item The definition of predicates about these types.
\end{enumerate}

The full syntax is given in Section \ref{subsec:syntaxconfig}.
\subsection{The maxprof parameter}
All trees have \emph{bounded} size, thus one must specify the maximum size of a tree. This is used in particular when compiling the \ocaml{TLink} predicate, see Section \ref{para:tlink}.

\subsection{Types}
Nodes, leaves and some operations on trees are \emph{typed}. These types are all defined in the configuration file, and are grouped in two families:
\begin{itemize}
\item Types without accessors; they will represent leaves.
\item Types with accessors; they will represent nodes. An accessor indicates the type of children and how to access it. There is two type of accessors:
  \begin{itemize}
  \item A simple accessor composed by a name and a type.
  \item Multiple accessors, composed by a name, a number and a type. The syntax \ocaml{10 f to site} will allow the use, on a variable \ocaml{x}, of \ocaml{x.f:0}, \ocaml{x.f:1}, to \ocaml{x.f:9}. This is semantically equivalent to define 10 different accessors.
  \end{itemize}
\end{itemize}

\subsection{Predicates}
\label{subsec:predicates}
Predicates can be used to extract information about nodes and leaves. Some predicates are bundled into the \Iota{} syntax itself:
\begin{itemize}
\item \ocaml{Eq} is a binary predicate expressing the fact that two literals are equals. It can be applied to literals of any types.
\item \ocaml{Link} is a binary predicate expressing the fact that two literals are linked. It can be applied to literals of any types, except when its use was restricted in the configuration file.
\item \ocaml{TLink<t1,t2>} is a binary predicate expressing the fact that the two trees of the literals are linked. Its arguments must be of type \ocaml{t1} and \ocaml{t2}.
\item \ocaml{Has} is a unary predicate expressing the \emph{presence} of a literal. It can be applied to literal of any types.
\end{itemize}

The user can specify other predicates using the configuration file. Note that user-defined predicates are \emph{typed}, meaning that, once defined, they can be applied only to one type of literal.

\paragraph{Static vs Dynamic}
Predicates are separated into two categories: static and dynamic. Dynamic predicates can be prepended with the symbol \ocaml{+} in the language. \ocaml{Eq}, \ocaml{Link} and \ocaml{Has} are dynamic.

\subsection{Constraints}
The \ocaml{Link} predicate is fully polymorphic but one can constrain its use, and force some types to be linked only to some others.

\subsection{Example}
Here is a valid configuration file:
\begin{minted}[frame=lines]{ocaml}
let maxprof = 10

type site
type rsite
type mol = m to mol | f to site | g to site
type bigmol = 5 tm to mol | rs to rsite

static E about mol
static S about site
static R about rsite
dynamic Active about mol
dynamic Open about site

Link rsite to site
\end{minted}

This file declares four types:

\begin{itemize}
\item A leaf \ocaml{site}.
\item A leaf \ocaml{rsite}.
\item A node \ocaml{mol} with three possible children:
  \begin{itemize}
  \item An other node \ocaml{mol}.
  \item Two sites \ocaml{f} and \ocaml{g}.
  \end{itemize}
\item A node \ocaml{bigmol} with five possible children of type \ocaml{mol}, and one of type \ocaml{rsite}
\end{itemize}

The last line specify a constraint: a leaf of type \ocaml{rsite} can only be linked to leaves of type \ocaml{site}.

\section{Semantics of a \Iota{} program}
Once the configuration is written, one can write a program using it. The syntax is fully described in Section \ref{subsec:syntaxprog}. A \Iota{} program is a file composed of four parts (the last three are exactly from Husson's thesis) :

\begin{enumerate}
\item A list of let-definitions.
\item A list of formulas (which may use the above definitions).
\item (optional) A list of formulas (which may use the above definitions) that must be ensured.
\item (optional) A list of formulas (which may use the above definitions) that must be maintained.
\end{enumerate}

\subsection{Propositional formulas}

\paragraph{Literals}
Formulas are about literals. A \Iota{} literal is either:
\begin{multicols}{2}
  \begin{itemize}
  \item A name.
  \item A child of a literal.
  \item The parent of a literal.
  \end{itemize}
\end{multicols}

\paragraph{Formulas}
Propositional formulas can be built over (fully applied) predicates on literals using usual combiners \ocaml{not}, \ocaml{&&} and \ocaml{||}.

\paragraph{Examples}
Here are some examples of formulas using the previous configuration:
\begin{minted}[frame=lines]{ocaml}
Active(x);
Active(x) && not (Active (x.m));
Has(x) && (not (Open(x.t)) || +Link(x.t,y.g))
\end{minted}

\subsection{Toward first-order}
Then, one can construct first-order formulas using the two following structures:
\begin{itemize}
\item \ocaml{forall x guards(x,y) -> formula(x)}
\item \ocaml{exists x guards(x,y) && formula(x)}
\end{itemize}
Notice that each quantified variable is \emph{guarded} by a (disjunctive) non-empty list of guards.

\paragraph{Guard}
A guard is a binary predicate involving exactly its two arguments. In \Iota{}, a guard is either \ocaml{Eq}, \ocaml{Link} or \ocaml{TLink}.

\subsection{Writing programs}
Now, we can wire up all these definitions using a standard let-syntax. Let-definitions are of the following form:
\begin{minted}[frame=lines]{ocaml}
let e x = E(x)
let f h x y = (h x) && (e y)
\end{minted}
There is a few things to note:
\begin{itemize}
\item Definitions are not recursive and are parsed up-to-bottom. Thus, in the example, \ocaml{f} can use \ocaml{e} but the converse is false.
\item All free variables of right hand-side must be in the left hand-side, with some exceptions (see Section \ref{subsec:guardinfer}).
\item The language is \emph{high-order}, meaning that one definition can take another definition as an argument.
\end{itemize}

\subsection{General parts}
A program is optionally followed by two lists:
\begin{enumerate}
\item A list of formulas that must be \emph{ensured}.
\item A list of formulas that must be \emph{maintained}.
\end{enumerate}

These lists are composed of formulas are universally quantified and must respect Husson's criterion (see Section \ref{subsec:verification}).

\subsection{Examples}
\label{configex}
\begin{minted}[frame=lines]{ocaml}
let activate_and_link x y = Link (x.f, y.g) && +Active(x)

in

Has(a) && (forall u Link(a,u) -> (E(u) || TLink<mol,mol>(x,u)));
(activate_and_link x y) || (activate_and_link x z)

ensure

Link (z.f, w.g) => (E(z) -> (E(w) && Open (z.f)))
\end{minted}


\section{The compilation back-end}
The compilation is divided into 5 steps:
\begin{enumerate}
\item Parsing.
\item Typechecking.
\item Compilation itself.
\item Guard inference.
\item Verification of the resulting structure.
\end{enumerate}

\subsection{Parsing}
The described syntax is parsed using the great \Menhir{}\cite{menhir}. A first pass is made after the parsing itself to ensure that the user uses the symbol \ocaml{+} only in front of declared dynamic predicates.

\subsection{Typechecking}
Programs are typechecked (using algorithm W) to ensure the validity of the file. Most of the inference is trivial. There is a challenge to infer the type of an expression using \ocaml{parent} since its usage introduce requirements about its argument (in the expression \ocaml{parent(x)}, \ocaml{x} must not be a root). This is bypassed using explicit typing of this operator.\\

\subsubsection{About constraints}
As mentioned before, the use of the \ocaml{Link} predicate can be constrained. The validity check is made by modifying the classical algorithm W implementation: let-definitions now carry a map to remember which variable is linked to which type. Moreover, the algorithm now tries at the end to instantiate each type variable (hence, if a program typecheck, we know fore sure that it exists at least a type for each variable respecting the links constraints).\\
In details, defined constraints give a function $type \to type\ list\ option$ which represents the ``linkability'' of a type:
\begin{itemize}
\item $None$ means that a node of this type can be linked to any node of any other type.
\item $Some\ xs$ means that a node of this type can only be linked to node that have its type in $xs$.
\end{itemize}
When typing with algorithm W, each definition carries a map of type $typevariable \to (typevariable, type)\ either$ registering which variable is linked to which type. Then, when discovering the ground type (a type without an arrow that is not a variable) corresponding to a type variable, we can ensure that constraints are respected.

For example (using the configuration given in Section \ref{configex}):
\begin{minted}[frame=lines]{ocaml}
let f x y z = R(x) && Link(x,y) && Link(y,z)
in
S(b) && f a b c
\end{minted}
The typing of \ocaml{f} generates (using Greek letters for type variable):\\

\begin{figure}[H]
  \centering
  \subfloat[The environment]{
    \begin{tabular}{l|l}
      Variable& Type\\
      \hline
      x&$rsite$\\
      y&$\alpha$\\
      z&$\beta$
    \end{tabular}
  }
  \quad\quad
  \subfloat[The link map]{
    \begin{tabular}{l|l}
      Type Variable&Links\\
      \hline
      $\alpha$ & $rsite, \beta$\\
      $\beta$ & $\alpha$
    \end{tabular}
  }
\end{figure}

Next, the typing of the main part gives:
\begin{figure}[H]
  \centering
  \subfloat[The configuration]{
    \begin{tabular}{l|l}
      Type& Type\\
      \hline
      $rsite$&$site$
    \end{tabular}
  }
  \quad\quad
  \subfloat[The environment]{
    \begin{tabular}{l|l}
      Variable& Type\\
      \hline
      a&$rsite$\\
      b&$site$\\
      c&$\beta$
    \end{tabular}
  }
  \quad\quad
  \subfloat[The link map]{
    \begin{tabular}{l|l}
      Type Variable&Links\\
      \hline
      $\beta$ & $site$
    \end{tabular}
  }
\end{figure}

Note that the line about the type variable $\alpha$ in tabular $(e)$ was dropped since we identified that $\alpha$ was instantiated here to $site$ \emph{and this specialization was legal regarding the configuration and the link map}.

We can then instantiated $\beta$ to any type, since the linkabilty of $site$ is not constrained.

\subsection{Compilation}
The compilation itself is divided into sub-steps.

\paragraph{Inlining}
All the definitions of \Iota{} are \emph{pure}, ie. without any effects, so one can always replace a call to a function by its body with proper substitution. This is the first thing the compiler do, since it allows to totally remove let-definitions. There are two sides effects:

\begin{itemize}
\item Unused definitions are not included in the result of the compilation. They still need to typecheck.
\item The size of the produced formula can be large since many things will be duplicated.
\end{itemize}

\paragraph{Compilation of TLink}
\label{para:tlink}
The \ocaml{Tlink} predicate is not included in the target language, so we need to compile it to a big disjunction of cases. Note that, thanks to the type system, the compilation of \ocaml{TLink} produces only valid (with respect to the type system and user-defined constraints) possibilities.

\paragraph{Optimization}
The compiler can now do some optimization. It actually does only one, by replacing expressions of the form:
\begin{minted}{ocaml}
parent<t1,t2>(x.f)
\end{minted}
by
\begin{minted}{ocaml}
x
\end{minted}
Note that this optimization is legal in the sense that, since the program typechecks, we know that \ocaml{x.f} is a valid object.

\subsection{Guard inference}
\label{subsec:guardinfer}
When writing a definition, it is convenient to see free variables as \emph{existentially} quantified ones. The problem is that, in \Iota{}, every quantified variable must be guarded. Thus we need to infer a guard for free variables in let-definitions. Some heuristics are used and one can write a definition such as:
\begin{minted}{ocaml}
let f x = Eq(x,z) && Link(x,z)
\end{minted}
which will be compiled to:
\begin{minted}{ocaml}
let f x = exists z Eq(x,z) && Link(x,z)
\end{minted}

\paragraph{Normal form of formulas}
Any formula can be put in a \emph{normal form}, where negation is only present on leaves. This is done here. Note that it was not possible to do it before, since we need to first infer guards to be able to negate them properly.

\subsection{Verification}
\label{subsec:verification}
The resulting structure must satisfy some properties. We must ensure that every guard is indeed a well-formed guard, and that the two parts ``ensure'' and ``maintain'' are well-formed. This pass only checks if these properties are respected.

\section{About the compiler}
\subsection{Compiling}
The compiler is written using \Ocaml{}\cite{ocaml}. It was designed to be built with \Dune{}\cite{dune}. It is itself separated into two components:

\begin{enumerate}
\item A library, located in \verb|lib/| were all the work is made. Its entry-point is \verb|lib/main.ml|. It is fully documented using \Odoc{}\cite{odoc}. Online documentation is available at: \url{https://nobrakal.github.io/iota/iota/}, or can be built using:
\begin{minted}{shell}
dune build @doc
\end{minted}
\item A front-end, located in \verb|bin/|, providing an executable able to launch the compilation of a file. It can be built using:
\begin{minted}{shell}
dune build bin/main.exe
\end{minted}
  The produced executable takes as argument the configuration file and the file itself. It outputs the result of the compilation or prints an error.
\end{enumerate}

\subsection{Testing}
Some efforts were made to be able to test the compiler. The test-suite is located in \verb|test/|. It can be ran using:
\begin{minted}{shell}
dune runtest
\end{minted}
For now, it ensures that files that must compile are indeed compiling, and files that must fail to compile are indeed failing.

\section{Conclusion}

\section{Syntax of the language}
Nota Bene:
\begin{itemize}
\item \verb|[<rule>]| symbolise a list of \verb|<rule>|.
\item \verb|[<rule> // <sep>]| symbolise a list of \verb|<rule>| separated by \verb|<sep>|.
\end{itemize}

Comments à-la-OCaml can be used everywhere.

\subsection{Syntax of configuration file}
\label{subsec:syntaxconfig} Here is a BNF syntax for the configuration file.
\begin{grammar}
  <constants> ::=
  \lit{let} \lit{maxprof} \lit{=} <int>

  <accessor> ::=
  <lident> \lit{to} <type>
  \alt <int> <lident> \lit{to} <type>

  <typedef> ::=
  \lit{type} <lident>
  \alt \lit{type} <lident> \lit{=} [<accessor> // \lit{|}]

  <preddef> ::=
  \lit{static} <hident> \lit{about} <lident>
  \alt \lit{dynamic} <hident> \lit{about} <lident>

  <constraint> ::=
  \lit{Link} <lident> \lit{to} [<lident> // \lit{|}]

  <config> ::=
  <constants> [<typedef>] [<preddef>] [<constraint>]
\end{grammar}

\subsection{Syntax of programs}
\label{subsec:syntaxprog} Here is a BNF syntax for a \Iota{} program.
\begin{grammar}
  <lident> ::= [a-z][a-zA-Z0-9]*

  <hident> ::= [A-Z][a-zA-Z0-9]*

  <type> ::= <lident>

  <term> ::= <lident>
  \alt `parent<' <type> `,' <type> `>(' <term> `)'
  \alt <term> `.' <lident> `:' <int>
  \alt <term> `.' <lident>

  <guard> ::= `Eq(' <term> `,' <term> `)'
  \alt `Link(' <term> `,' <term> `)'
  \alt `TLink<' <type> `,' <type> `>(' <term> `,' <term> `)'

  <predicate> ::= <guard>
  \alt `Has(' <term> `)'
  \alt <hident> `(' <term> `)'

  <formula> ::= <predicate>
  \alt `+'<predicate>
  \alt `not' <formula>
  \alt <formula> `&&' <formula>
  \alt <formula> `||' <formula>
  \alt `(' <formula> `)'

  <safe> ::= <formula>
  \alt <term>
  \alt <safe> `&&' <safe>
  \alt <safe> `||' <safe>
  \alt `forall' <lident> `(' [<guard> // \lit{||}] `)' `->' <safe>
  \alt `exists' <lident> `(' [<guard> // \lit{||}] `)' `&&' <safe>
  \alt <safe> <safe>
  \alt `(' <safe> `)'

  <letdef> ::= \lit{let} <lident> [<lident>] \lit{=} <safe>

  <general> ::=
  <guard> \lit{->} <general>
  \alt \lit{=>} <formula>

  <program> ::=
  [<letdef>] \lit{in} [<safe> // \lit{;}] \lit{ensure} [<general> // \lit{;}] \lit{maintain} [<general> // \lit{;}]

\end{grammar}

\bibliographystyle{plain}
\bibliography{publications}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
